name: Validate Website Submissions

on:
  workflow_dispatch:

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Process Issues
        uses: actions/github-script@v7
        with:
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'new-site',
              state: 'open'
            });

            console.log(`Found ${issues.length} new site submissions`);

            for (const issue of issues) {
              console.log(`Processing issue #${issue.number}: ${issue.title}`);

              // Extract form data using regex
              const urlMatch = issue.body.match(/### Website URL\s*\n\s*(.+)/);
              const authorMatch = issue.body.match(/### Author Name\s*\n\s*(.+)/);

              const url = urlMatch ? urlMatch[1].trim() : '';
              const author = authorMatch ? authorMatch[1].trim() : '';

              if (!url) {
                console.log(`No URL found in issue #${issue.number}`);
                continue;
              }

              console.log(`Validating ${url} by ${author}`);

              // Basic URL validation
              if (!url.match(/^https?:\/\//)) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: 'ðŸ¤– **Validation Failed**\n\nURL must start with http:// or https://'
                });

                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['validation-failed']
                });
                continue;
              }

              try {
                // Check if site is accessible
                const response = await fetch(url, { method: 'HEAD', timeout: 10000 });

                if (response.ok) {
                  // Get site title from the page
                  const pageResponse = await fetch(url);
                  const html = await pageResponse.text();
                  const titleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
                  const siteTitle = titleMatch ? titleMatch[1].trim() : new URL(url).hostname;

                  // Read current sites.json
                  const { data: sitesFile } = await github.rest.repos.getContent({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: 'data/sites.json'
                  });

                  const sitesData = JSON.parse(Buffer.from(sitesFile.content, 'base64').toString());

                  // Check if site already exists
                  const siteHostname = new URL(url).hostname;
                  const existingSite = sitesData.sites.find(site =>
                    new URL(site.url).hostname === siteHostname
                  );

                  if (existingSite) {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `ðŸ¤– **Already in webring**\n\nThis site is already part of the webring.`
                    });

                    await github.rest.issues.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      state: 'closed'
                    });
                    continue;
                  }

                  // Add new site
                  const newSite = {
                    id: siteHostname.replace(/\./g, '-'),
                    url: url,
                    title: siteTitle,
                    author: author,
                    dateAdded: new Date().toISOString(),
                    active: true
                  };

                  sitesData.sites.push(newSite);
                  sitesData.totalSites = sitesData.sites.length;
                  sitesData.lastUpdated = new Date().toISOString();

                  // Update sites.json
                  await github.rest.repos.createOrUpdateFileContents({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: 'data/sites.json',
                    message: `Add ${siteTitle} to webring`,
                    content: Buffer.from(JSON.stringify(sitesData, null, 2)).toString('base64'),
                    sha: sitesFile.sha
                  });

                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `ðŸŽ‰ **Added to webring!**\n\n**Site:** [${siteTitle}](${url})\n**Author:** ${author}\n\nYour site has been added to the webring. Please add the widget to your site:\n\n\`\`\`html\n<div id="webring-widget" data-theme="light" data-style="compact"></div>\n<script src="https://open-making.github.io/webring/widget/webring.js"></script>\n\`\`\``
                  });

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'closed'
                  });
                } else {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: 'ðŸ¤– **Validation Failed**\n\nWebsite is not accessible or returns an error'
                  });

                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: ['validation-failed']
                  });
                }
              } catch (error) {
                console.error(`Error validating ${url}:`, error);
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: 'ðŸ¤– **Validation Failed**\n\nWebsite is not accessible or validation timed out'
                });

                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['validation-failed']
                });
              }
            }